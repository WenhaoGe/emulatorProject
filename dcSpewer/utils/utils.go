package utils

import (
	"bytes"
	"crypto"
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"fmt"
	"io"

	"context"
	"encoding/json"
	"net/http"
	"time"

	"strings"

	"bitbucket-eng-sjc1.cisco.com/an/apollo-test/dcSpewer/config"
	"bitbucket-eng-sjc1.cisco.com/an/barcelona/adconnector"
	adcore_base "bitbucket-eng-sjc1.cisco.com/an/barcelona/adcore/base"
	"bitbucket-eng-sjc1.cisco.com/an/barcelona/adutil"
	"github.com/gorilla/websocket"
)

func NewRandStr(l int) string {
	rs := make([]byte, l)
	n, err := io.ReadFull(rand.Reader, rs)
	if n != len(rs) || err != nil {
		// can't do much without reading from 'rand'
		panic(err)
	}
	return fmt.Sprintf("%x", rs)
}

func GenerateRsaKeyPair() (privateKey *rsa.PrivateKey, publicKeyPem string) {
	var err error
	privateKey, err = rsa.GenerateKey(rand.Reader, 2048)
	if err != nil {
		panic(err)
	}

	pubkey_bytes, err := x509.MarshalPKIXPublicKey(&privateKey.PublicKey)
	if err != nil {
		panic(err)
	}
	publicKeyPem = string(pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PUBLIC KEY",
			Bytes: pubkey_bytes,
		},
	))
	return
}

const clientHelloMagic = "0xfab994b7168ca09a3edc"

// Message values sent to a device on authentication completion
const (
	authStatusSuccess = iota // Authentication of the given signature succeeded
	//authStatusFail           // Authentication of the given signature failed
)

func ClientAuth(ws *websocket.Conn, privateKey *rsa.PrivateKey) error {

	// Send the hello message
	err := ws.WriteMessage(websocket.BinaryMessage, []byte(clientHelloMagic))
	if err != nil {
		return err
	}

	// Read the nonce generated by the server
	t, msg, err := ws.ReadMessage()
	if err != nil {
		return err
	}

	if t != websocket.BinaryMessage {
		return errors.New("Nonce message is of wrong format")
	}

	// Hash and sign the nonce
	h := crypto.SHA256.New()
	_, err = h.Write(msg)
	if err != nil {
		return err
	}

	signed, err := rsa.SignPKCS1v15(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil))
	if err != nil {
		return err
	}

	// Send the signature
	err = ws.WriteMessage(websocket.BinaryMessage, signed)
	if err != nil {
		return err
	}

	// Read the result of the authentication
	t, msg, err = ws.ReadMessage()
	if err != nil {
		return err
	}

	if t != websocket.BinaryMessage {
		return errors.New("Auth response message is of wrong format")
	}

	if len(msg) == 1 && msg[0] == authStatusSuccess {
		return nil
	}
	var buf bytes.Buffer
	for i, m := range msg {
		buf.WriteString(fmt.Sprintf("msg[%d]:%d ", i, m))
	}
	return errors.New("Failed to authenticate identity with intersight")
}

// Represents a device registration request
type Registration struct {
	ApiVersion       int
	DeviceHostname   []string
	DeviceIpAddress  []string
	ExecutionMode    string
	Pid              []string
	PlatformType     string
	PublicAccessKey  string
	Serial           []string
	Vendor           string
	ConnectorVersion string
	ParentSignature  *ParentSignature
	Tags             []map[string]interface{}
}

type ParentSignature struct {
	DeviceId  string
	NodeId    string
	Signature []byte
	TimeStamp time.Time
}

type RegistrationOut struct {
	AccessKeyId   string
	Moid          string
	SecurityToken MoRef
}

type RegistrationOutSecToken struct {
	SecurityToken string
}

type MoRef struct {
	Moid string
}

type SecurityToken struct {
	Token string
}

type Dispatcher interface {
	Dispatch(ctx context.Context, message io.Reader)
	SendRestStim(ctx context.Context, body map[string]interface{}, method, url string) error
	StartChildDc(ctx context.Context, childConfig config.DeviceConfiguration)
	PrepInvEventsPayload(ctx context.Context, childConfig config.DeviceConfiguration, portStr string) ([][]byte, error)
	EnableBladeDc(ctx context.Context, chassisSerial string, chassisId int) error
	GetChildConfig(ctx context.Context) map[string]config.DeviceConfiguration
	PostRaw(ctx context.Context, url string, header http.Header, body map[string]interface{}) ([]byte, int, http.Header, error)
	GetRaw(url string, header http.Header) ([]byte, int, http.Header, error)
	GetIdentity() string
	UpdateVersion(version string)
	GetVersion() string
	ToggleConnection()
}

type DebugTraceMessage struct {
	Async    bool
	Type     string
	Request  []byte
	Response []byte
}

func parseDebugTraceFile(r io.Reader, platformType, nodeId string) error {
	dec := json.NewDecoder(r)

	_, err := dec.Token()
	if err != nil {
		return err
	}

	platformTrace, ok := traceResponses[platformType]
	if !ok {
		platformTrace = make(nodeResponses)
		traceResponses[platformType] = platformTrace
	}

	platformTrace[nodeId] = make(pluginResponses)
	for dec.More() {
		trace := &DebugTraceMessage{}
		err = dec.Decode(trace)
		if err != nil {
			return err
		}

		// Ignore Job and async responses for now
		if !trace.Async && trace.Type != "TypeJobStim" {
			if trsps, ok := platformTrace[nodeId][trace.Type]; ok {
				trsps[string(trace.Request)] = trace.Response
			} else {
				platformTrace[nodeId][trace.Type] = make(map[string][]byte)
				platformTrace[nodeId][trace.Type][string(trace.Request)] = trace.Response
			}
		}
	}

	return nil
}

// Map platform types to node responses
var traceResponses = make(map[string]nodeResponses)

// Map of plugin types to map of Cloud request body to device response body
type pluginResponses map[string]map[string][]byte

// Map of node id to plugin responses
type nodeResponses map[string]pluginResponses

func GetTraceResponses() map[string]nodeResponses {
	return traceResponses
}

func GetTraceFromContext(ctx context.Context) *TraceType {
	return ctx.Value(traceKey).(*TraceType)
}

func GetPluginResponses() {
	//
}

func GetTraceResponse(ctx context.Context, msgType string, req []byte) io.Reader {
	traceType, ok := ctx.Value(traceKey).(*TraceType)
	if !ok {
		return nil
	}

	platformResponses, ok := traceResponses[traceType.Platform]
	if !ok {
		return nil // Platform has no traces
	}

	// Check for requests specifically for this node
	if noderesponses, ok := platformResponses[traceType.Node]; ok {
		if typeresponses, ok := noderesponses[msgType]; ok {
			if rsp, ok := typeresponses[string(req)]; ok {
				return bytes.NewReader(rsp)
			}
		}
	}

	// Check for requests for the overall platform
	if noderesponses, ok := platformResponses[""]; ok {
		if typeresponses, ok := noderesponses[msgType]; ok {
			if rsp, ok := typeresponses[string(req)]; ok {
				return bytes.NewReader(rsp)
			}
		}
	}

	return nil
}

type traceKeyType int

const traceKey traceKeyType = 1

type TraceType struct {
	Platform   string
	Node       string
	Uuid       string // unique id for this trace
	Serial     []string
	Ip         []string
	ParentNode string
	DeviceMoid string
	Config     *config.DeviceConfiguration
}

func CreateTraceContext(ctx context.Context, trace *TraceType) context.Context {
	return context.WithValue(ctx, traceKey, trace)
}

// Ranges over all configuration in the input and attempts to download and parse the traces.
func PopulateTraces(config config.DeviceConfiguration) error {
	err := populateTrace(config.DebugTraceLog, config.PlatformType, "")
	if err != nil {
		return err
	}
	for _, node := range config.Nodes {
		err = populateTrace(node.DebugTraceLog, config.PlatformType, node.NodeId)
		if err != nil {
			return err
		}
	}

	for _, child := range config.Children {
		err = PopulateTraces(child)
		if err != nil {
			return err
		}
	}
	return nil
}

func populateTrace(url string, platform string, node string) error {
	if url == "" {
		return nil
	}

	// If entry already exists in global map throw error
	if platformTraces, ok := traceResponses[platform]; ok {
		if _, ok := platformTraces[node]; ok {
			return fmt.Errorf("trace defined multiple times for: %s : %s", platform, node)
		}
	}

	// Attempt download of trace file.
	resp, err := http.Get(url) // #nosec
	if err != nil {
		return err
	}

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("unable to download trace file. server responded with status code: %d", resp.StatusCode)
	}

	defer func() {
		cerr := resp.Body.Close()
		if cerr != nil {
			fmt.Println("failed to close response body: ", cerr.Error())
		}
	}()

	return parseDebugTraceFile(resp.Body, platform, node)

}

// Error state reported in API if initial setup of emulator fails.
var errorState string

func SetErrorState(in string) {
	errorState = in
}

func GetErrorState() string {
	return errorState
}

// Defines an inventory configuration done by a user to an emulated connection
type InventoryConfiguration struct {
	// The node id to apply the config to
	// If empty applies to the primary connection.
	NodeId string

	// List of objects to modify
	Objects []InventoryObject
}

type invAction string

const (
	UpdateInventory invAction = "update"
	AddInventory    invAction = "add"
	DeleteInventory invAction = "delete"
)

type InventoryObject struct {
	// The action to apply to the inventory
	Action invAction

	// The type of object this mo is
	// e.g. for UCSM the class name
	ObjectType string

	// The identity of the object in the database
	// e.g. in UCSM inventory the dn
	Identity string

	// The set of attributes to change.
	Properties map[string]interface{}
}

func init() {
	wLimiter = &workLimiter{}
	wLimiter.workQueues = make([]chan struct{}, InventoryWork+1)
	for i := 0; i <= int(InventoryWork); i++ {
		wLimiter.workQueues[i] = make(chan struct{}, 8)
	}
}

func GetMessageReader(ctx context.Context, header adconnector.Header, body io.Reader) (io.Reader, error) {
	if len(header.Type) == 0 {
		return nil, errors.New("Invalid header, Type must be set")
	}
	if body == nil {
		header.BodySize = -1
	} else {
		switch body := body.(type) {
		case *strings.Reader:
			header.BodySize = body.Len()
		case *bytes.Buffer:
			header.BodySize = body.Len()
		default:
			return nil, fmt.Errorf("unknown body type")
		}
	}
	// Populate trace id in header if not already set
	if len(header.TraceId) == 0 {
		// Attempt to retrieve trace id from context
		ep, ok := adcore_base.FromContext(ctx)
		if !ok {
			if adutil.IsDeviceConnector() {
				header.TraceId = adutil.GenerateTraceId("DC")
			} else {
				header.TraceId = adutil.GenerateTraceId("TDC")
			}
		} else {
			header.TraceId = ep.TraceId
		}
	}

	hbuf := bytes.NewBuffer(nil)
	enc := json.NewEncoder(hbuf)
	err := enc.Encode(header)
	if err != nil {
		return nil, errors.New("Unable to serialize message header")
	}

	hdrsize := fmt.Sprintf("%06d", hbuf.Len())

	var outr io.Reader
	if body == nil {
		outr = io.MultiReader(bytes.NewReader([]byte(hdrsize)), hbuf)
	} else {
		outr = io.MultiReader(bytes.NewReader([]byte(hdrsize)), hbuf, body)
	}
	return outr, nil
}

var wLimiter *workLimiter

type workLimiter struct {
	workQueues []chan struct{}
}

type workType int

const (
	ControlWork workType = iota
	InventoryWork
)

func DoingWork(ctx context.Context, work workType) {
	wLimiter.workQueues[work] <- struct{}{}
}

func DoneWork(ctx context.Context, work workType) {
	<-wLimiter.workQueues[work]
}
